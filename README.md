# 【Python教程】《零基础入门学习Python》最新版（完结撒花🎉）
[B站视频链接](https://www.bilibili.com/video/BV1c4411e77t/)

## 编写代码时的注意事项
编写代码时要注意中英文标点符号，除了字符串中可以用中文标点，其他**涉及到代码的标点必须使用英文标点**。相同代码块下的语句中出现的空格不影响编译，只是为了美观，你可以更具自己的喜好选择要不要加空格。

本文编写的代码大部分可以直接运行在python安装的IDLE中，也可以使用Microsoft visual studio code和Microsoft visual studio等其他软件编写。在其他第三方IDLE中，可能不会像官方的IDLE中访问之后就能直接返回结果，这个时候建议使用`print()`将结果打印出来。


## 变量

**变量：只是一个名字，不是盒子**

### 一、创建变量
很简单，用赋值运算符就可以完成
```python
#使用语法（仅表示语法结构，代码是不能运行在idle中的）
变量名 = 值（内容）

#示例
x = 3
```

其中“=”为赋值运算符，将等号右边的值赋给等号左边的变量名
**(注：变量名不可以以数字开头，且区分大小写；python3以上变量名支持中文)**

### 二、访问变量

直接打变量名就好

### 三、调换变量值

*1、用中间变量*

通过中间变量来实现变量值的调换，代码如下：

```python
x = 3
y = 2
z = x
x = y
y = z

#通过元组（后续会有介绍）来调换变量值，代码如下：
x,y = y,x
```

## 字符串（第一部分）

**可以理解为就是文本**。用单引号、双引号、三引号包裹起来 **（注：引号必须成对使用，且不能混用(单引号对双引号之类的)，有时需要及时变通；看如下例子）**

```python
#以下是错误的代码
print('Let's go!') #Let`s中的缩写会被程序认为 “Let”是字符串，而“s go！'”是一个无头的字符串
#以下是正确的代码
print("let`s go!") #这是需要将外面的单引号变为双引号，可以防止程序出现歧义
```

### 1、转义字符

如果一个文本中既有双引号又有单引号，这是推荐使用转义字符来实现

例如，用python打印"Life id short,let`s learn Python"，该文本中既有单引号又有双引号，需要用到转义字符，代码如下

```python
print('\"Life is short,let\`s learn Python\"') #用转义字符能让程序识别出单引号和双引号，此时外围的引号只要一样且成对即可
```

由上述代码可知，转义字符用\\+后缀来表示

其他的转义字符如下

| 符号 |       说明       |
| :---: | :---------------: |
|  \\\  |    反斜杠（\）    |
|  \\'  |    单引号（'）    |
|  \\"  |    双引号（"）    |
|  \\a  |    响铃（BEL）    |
|  \\b  |   退格符（BS）   |
|  \\n  |   换行符（LS）   |
|  \\t  | 水平制表符（TAB） |
|  \\v  | 垂直制表符（VT） |
|  \\r  |   回车符（CR）   |
|  \\f  |   换页符（FF）   |
| \\ooo |   ooo为八进制数   |
| \\xhh |  hh为十六进制数  |

### 2、原始字符串

总所周知，文件路径中含有反斜杠，而反斜杠后带的字母刚好是转义字符时，程序也依然会按照转义字符去编译，这时为了不产生歧义需要用到原始字符串，来让程序不对字符串中的转义符进行解释,即在字符串前面加上一个小写 `r`。例如

```python
print("D:\three\two\one\now") #文件路径中的反斜杠和后面带着的字母刚好组成反斜杠，让程序认为是转义字符

#正确表达路径方式如下
print("D:\\three\\two\\one\\now") #字符串中含有少量的反斜杠时，可以选择增加一个反斜杠来使其达到目的 
print(r"D:\three\two\one\now") #加上r说明该字符串就是原始字符串，程序不会对其中的转义符进行解释
```

**注：使用反斜杠时，注意不能在字符串的末尾，字符串的末尾出现反斜杠会让程序认为这还没有结束！**

### 3、长字符串

如果字符串的内容需要换行表示，此前用转义字符中的换行符 `\n`来实现，到此可用到长字符串来实现。长字符串用 `'''`或 `"""`表示（引号必须成对使用），例如：

```python
poetry = """
静夜思 李白
床前明月光，
疑是地上霜。
举头望明月，
低头思故乡。
"""
```

从头到尾，没有使用换行符，即可实现换行。

### 4、字符串的加法和乘法

字符串的加法和数值的加法有区别，例如

```python
a = "520"
b = "1314"
print(a+b) #此时变量a和b均为字符串，打印出的结果为'5201314',即对字符串进行了拼接
```

乘法就是对字符串重复打印，可自行测试如下代码：

```python
print("我今天一定要好好学习"*3000)
print("我今天一定要好好学习\n"*3000)
```

## 数字类型

### 整数

就是你学到的整数，和你之前学的整数没有任何区别，_真的没必要说_

### 浮点数

可以粗略理解为小数。为什么说粗略理解为小数呢？可以测试先看如下代码

```python
a = 0.1
b = 0.2
print(a+b)
```

如果不死心的同学可以尝试如下代码：

```
a = 0.1
b = 0.2
0.3 == a+b
```

不出意外的话，打印的结果不是0.3，而是0.30000000000000004；返回的值也是false。这是因为python和C语言一样，采用IEEE754的标准来存储浮点数，故浮点数会有误差。

#### 如何精确的计算浮点数？

想要精确的计算浮点数需要用到decimal模块。此模块程序不是默认启用的，需要导入 `import decimal`。然后通过该模块，计算浮点数。具体代码如下：

```python
import decimal
a = decimal.Decimal('0.1') #括号内为字符串
b = decimal.Decimal('0.2')
print(a+b)
```

此时，计算的结果就是0.3

### 复数

和学到的复数是一样的，分为实部和虚部，但在python中虚部的i用j表示，故python中复数表示为 `1+2j`

#### 获取一个复数的实部和虚部

在python中能够通过代码来获取复数的实部和虚部，代码如下

```python
x = 1+2j
x.real #获取复数x的实部
x.imag #获取复数x的虚部
```

## 数字运算

### 数字运算表

|      操作      |               结果               |
| :------------: | :------------------------------: |
|      x+y      |            x加y的结果            |
|      x-y      |            x减y的结果            |
|      x*y      |            x乘y的结果            |
|      x/y      |           x除以y的结果           |
|      x//y      |     x除以y的结果（地板除¹）     |
|      x%y      |           x除以y的余数           |
|       -x       |            x的相反数            |
|       +x       |              x本身              |
|     abs(x)     |      x的绝对值，或复数的模       |
|     int(x)     |   将x转换成整数（丢掉小数部分）    |
|    float(x)    |         将x转换成浮点数         |
| complex(re,im)² | 返回一个复数，re是实部，im是虚部 |
| c.conjugate() |         返回c的共轭复数         |
|  divmod(x,y)  |        返回（x//y，x%y）        |
|    pow(x,y)³    |           计算x的y次方           |
|      x**y      |           计算x的y次方           |

1、地板除：两数所求得的商进行**向下取整**。以下是两个例子，含有正数和负数的情况：

```python
a,b = 3,2
print(a//b) #返回值应该是1
x,y = -3,2
print(x//y) #返回值应该是-2
```
从上述的例子看，地板除为向下取整，而不是直接去除小数部分。

2、complex(re,im)：该函数输入的数据要么以整数或浮点数虚实部分开传入，要么就直接输入（也可以用字符串传入,但在字符串中不能出现空格）整个复数。代码如下：
```python
#错误的代码
complex("1","2")
complex("1 + 2j")
#正确的代码
complex(1,2)
complex("1+2j")
complex(1+2j)
```
错误的代码演示了分别传入字符串和字符串中出现空格的情况。

3、pow(x,y)：通常情况下该函数和 `x**y` 没有区别，但是该函数支持输入第三个参数。该参数表示将幂运算的结果与此参数进行取余运算。可以尝试如下代码
```python
pow(2,3,5)
```
输出的结果应该是3（为2的3次方后除以5的余数）

## 布尔类型
结果为 `True` 或 `False` 的数值类型。可用函数 `bool()` 进行检测。代码如下：
```python
bool(True)
bool(False)
bool("520")
bool(520)
bool("False")
bool("1")
bool("0")
bool(0)
bool(0.0)
bool({})
bool("")
```
由上述代码返回的值总结出，返回值为`False`的情景为：

1、定义为False的对象：None和False

2、值为0的数字类型：包括整数，浮点数，复数等等

3、空的序列和集合：`""`、`()`、`[]`、`{}`、`range(0)`、`set(0)`

下面看如下代码：
```python
1 == true
0 == false
```
返回值都为True，则上述等式成立，换言之布尔类型就是特殊的整数类型，因此布尔类型也可以参与一些运算：
```python
True + False
True - False
True * False
True / False #这一行会报错，0不能做为除数
```

## 逻辑运算符
**和、且、非**：和高中学的一样的
| 运算符 | 含义 |
|:---:|:---:|
| and | 符号左右两边同时为True |
| or | 符号左右两边满足一个True |
| not | 如果操作数为True，返回False；如果操作数为False，返回True |

### and（和/与）
使用方式如下：
```python
3 < 4 and 7 > 5  #返回True
3 > 4 and 7 > 5  #返回False
3 > 4 and 7 < 5  #返回False
```
判断真假的式子放在and两边

### or（且/或）
使用方式和`and`相差不大：
```python
3 < 4 or 7 > 5  #返回True
3 > 4 or 7 > 5  #返回True
3 > 4 or 7 < 5  #返回False
```
判断真假的式子放在`or`两边

### not（非）
使用方式与`and`和`or`有区别，看如下代码：
```python
not True  #返回False
not False  #返回True
not 520  #返回False
not 0 #返回True
```
判断真假的式子放在`not`后面

## 短路逻辑
Python中能对任何对象做真值测试（测试该对象的布尔值）。数值作为对象也能参与真值测试，请看如下代码：
```python
3 and 4 #返回4
4 or 5 #返回4
"nuist" and "njtech"  #返回'njtech'
"njtech" and 520  #返回'njtech'
```
**短路逻辑核心思想**：从左往右，只有当第一个操作数的值无法确定逻辑运算的结果时，才对第二个操作数进行求值。或者是返回直接影响最后结果的对象。逻辑运算符是遵循短路逻辑的。

1、`and`：当左右两边的对象都为`True`才能得出结果`True`，此时影响最后结果的值为后一个对象；当左边为`True`,右边为`False`时，此时影响最后结果的值为后一个对象，则输出后一个对象的值；当左边为`False`时，由于`and`中出现`False`即返回`False`,换言之此时的第一个对象就能判断结果，则输出第一个对象。
```python
3 and 4 #返回4
3 and 0 #返回0
0 and 3 #返回0
0 and 0 #返回0
```
2、`or`：（和`and`相反）逻辑是一样的，只不过是判断的是false
```python
3 or 4 #返回3
3 or 0 #返回3
0 or 3 #返回3
0 or 0 #返回0
```

## 运算符的优先级
运算表达式执行的先后顺序，和四则运算顺序类似，小括号最高级，编写程序时想要谁先算可以加小括号来解决问题

### 运算优先级顺序表
_注：优先级数越高，越先被计算_
| 优先级 | 运算符 | 描述 |
|:-----:|:------:|:----:|
|1|`lambda`|Lambda表达式
|2|if-else|条件表达式
|3|`or`|布尔“或”
|4|`and`|布尔“与”
|5|`not x`|布尔“非”
|6|`in`,`not in`,`is`,`is not`,`<`,`>`,`<=`,`>=`,`==`,`!=`|成员测试，同一性测试，比较
|7|`\|`|按位或
|8|`^`|按位异或
|9|`&`|按位与
|10|<<,>>|移位
|11|+,-|加法，减法
|12|*,@,/,//,%|乘法，矩阵乘法，除法，地板除，取余数
|13|+x,-x,~x|正号，负号，按位翻转
|14|**|指数|
|15|await x|Await表达式|
|16|x[index],x[index:index],x(arguments...),x.attrubute|下标，切片，函数调用，属性引用|
|17|(expressions...),[expressions...],{key:value...},{expressions...}|绑定或元组显示，列表显示,字典显示，集合显示|


## 绘制流程图
开始编写代码前需要了解自己的代码要完成什么事情，绘制出流程图，帮助以后很好的编写代码。

*和高中学的流程图一样的*

## 分支和循环
### 分支结构
在python中，分支结构通过`if`语句来实现，python中一共有5种`if`语句。
#### 一、判断条件成立，执行包含代码（块）
语法结构如下
```python
#示例（仅表示语法结构，代码是不能运行在idle中的）
if conditions:
    statement(s)
    statement(s)
#例如
if 1>0:
    print("1是大于0的")

#例如（if后条件为False）
if 1<0:
    print("打印这段话")
```
上述示例中，if后面的`conditions`应该为一个可以判断布尔类型的对象，这样程序才能继续运行。在python中，通过缩进来区分代码块。上述例子中`statement(s)`前面（4个空格）的缩进表示一个代码块，且包含在`if conditions:`下面。**同一个代码块下面的代码缩进是相同的。**

上述的第二段代码中，if后条件为False，程序就不会执行其包含的代码（块）


#### 二、判断一个条件，若成立执行包含代码（块），不成立执行另外的代码（块）
语法结构如下
```python
#示例（仅表示语法结构，代码是不能运行在idle中的）
if conditions:
    statement(s)
else:
    statement(s)
#例如
if 1>2:
    print("1是大于2的")
else:
    print("1是小于2的")
```
上述例子中，1>2是False的，程序就不会执行if包含的代码，而是执行else包含的代码。因此如果if中的代码为假，且有`else`紧跟在if的后面，那么程序就会执行`else`中的代码（块）。


#### 三、判断多个条件，第一条件不成立继续判断第下一条件，直到条件成立为止
语法结构如下：
```python
#示例（仅表示语法结构，代码是不能运行在idle中的）
if condition1:
    statement(S)
elif condition2:
    statement(S)
elif condition3:
    statement(S)
elif condition4:
    statement(S)
.....
#例如（下面代码无法直接在idle中执行！请新建一个项目，将下面的代码敲进去，然后进入Run Model执行）
score = int(input("请输入你的分数："))
if 0<=score<60:
    print("不及格")
elif 60<=score<70:
    print("D")
elif 70<=score<80:
    print("C")
elif 80<=score<90:
    print("B")
elif 90<=score<100:
    print("A")
elif score == 100:
    print("S")
```
上述例子中，虽然只用`if`也可以做到类似的效果，但是只用`if`的效率远不及`elif`。因为只用if时需要判断完所有条件，而`elif`遇到了成立的条件后执行完该条件包含的代码后，后续的条件不再进行判断，直接结束。

#### 四、判断多个条件，所有条件不成立，执行其他内容
```python
#示例（仅表示语法结构，代码是不能运行在idle中的）
if condition1:
    statement(S)
elif condition2:
    statement(S)
elif condition3:
    statement(S)
elif condition4:
    statement(S)
else:
    statement(S)
.....
#例如（下面代码无法直接在idle中执行！请新建一个项目，将下面的代码敲进去，然后进入Run Model执行）
score = int(input("请输入你的分数："))
if 0<=score<60:
    print("不及格")
elif 60<=score<70:
    print("D")
elif 70<=score<80:
    print("C")
elif 80<=score<90:
    print("B")
elif 90<=score<100:
    print("A")
elif score == 100:
    print("S")
else:
    print("请输入0~100之内的分数")
```
上面的例子在第三种情况后添加了`else`，补充上述条件均不成立的时，输出`else`后的内容。在上述例子中，如果输入101，则会输出“请输入0~100之内的分数”。

#### 五、整合成条件表达式
*不推荐使用这种方式，太酷炫了，一时很难反应过来写的是什么，增加维护代码的成本*

语法结构如下：
```python
#示例（仅表示语法结构，代码是不能运行在idle中的）
条件成立时执行的语句 if condition else 条件不成立时执行的语句
#例如
print("1小于2") if 1<2 else print("1不小于2")
```
语法为：条件放在中央，左边放条件成立时执行的代码，右边放条件不成立时执行的代码。

**真的不建议用这种** ~~除非你真的想装逼~~


### 循环结构
在python中，有两种循环语句——`while`循环和`for`循环

#### While循环
就是通过条件来决定循环体的内容是否重复去执行。语法结构如下：
```python
#示例（仅表示语法结构，代码是不能运行在idle中的）
while condition:
    statement(S)
#例如
day = 0
while day <= 7:
    print("你今天学习了吗？")
    day = day + 1 #该句可简写为 day += 1  也是一样的效果
print("你已经坚持学习了7天啦~")
```
在while循环中，while后面的条件（该条件也应该能够判断布尔值）如果一直成立，那么将重复执行循环体内的内容，直到该条件不成立时。例如上述代码中，`day`的值小于等于7时会重复执行循环体内的内容，直到`day`的值大于7的时候停止执行循环体内的内容，执行循环外的内容。

*如果不小心误入死循环（循环体一直循环而无法跳出，平常称为死机）的时候，~~请等待电脑的电量耗完，或者将电脑断电~~，请按下`Ctrl`+`C`来结束程序*

#### 死循环
循环体一直循环而无法跳出，平常称为死机。死循环多数情况下是有害的，但是有些情况下会有意设置死循环。

#### break语句
break可以使程序马上跳出**循环体**，循环体内之后的代码不会再执行，而执行循环外的代码。通常存在于循环体内的分支结构中，语法如下：
```python
#示例（仅表示语法结构，代码是不能运行在idle中的）
while True:
    statement(S)
    break
    statement(S) #代码前面存在break已经跳出循环体，该句代码不会被执行

#示例2：循环体内存在分支结构
while True:
    statements(S)
    if True:
        break
    statements(S) #代码前面的分支结构中已经执行了break跳出了循环体（if是分支结构，不是循环体）故该句代码依然不会被执行
```
前面说过死循环多数情况下是有害的，有时候也会故意为之，例如下面这个“输入密码”的例子：
```python
while True:
    keyword = int(input("请输入密码："))
    if keyword == 114514:
        break
    print("密码错误！")
print("密码正确~请进~")
```
上述代码中，如果一直不能输入正确的密码，将会一直被困在循环体内，直到输入正确的密码执行了分支结构中的break，从而跳出循环。

#### continue语句
continue语句也可以让程序跳出循环体，但是只是跳出本轮循环，之后程序依然会从循环体的条件判断位置继续运行，如果条件仍然成立，则继续运行循环体内的内容。和break语句一样的是，也通常存在于循环体内的分支结构中，语法如下：
```python
#示例（仅表示语法结构，代码是不能运行在idle中的）
while True:
    statement(S)
    continue
    statement(S) #代码前面存在continue已经结束循环体，该句代码不会被执行

#示例2：循环体内存在分支结构
while True:
    statements(S)
    if condition:
        continue
    statements(S) #若前面的if分支结构条件为真，那么会执行condition离开循环，则该句代码不会被执行；若前面的分支结构条件为假，则继续执行循环体内的内容，此时会执行该句代码
```
continue语句一般用于找奇数，找偶数之类的等等。例如：
```python
i = 0
while i<100:
    i += 1
    if i % 2 == 0:
        continue #遇到偶数跳出循环重新开始循环
    print(i)
```
上述代码可以寻找100以内的奇数，当遇到偶数时，if分支结构中的条件成立，执行continue跳出循环，从头开始。

#### else语句
else在分支结构中，能很方便地执行if条件不成立时需要执行的代码（块）。同理，在循环结构中，如果执行**循环体的条件不再为真**时，会执行else中的代码（块）。语法结构如下：
```python
while False:
    statement(s)
else:
    statement(S)
```
看到这里回想就算把`else`里面的代码放到循环体外，当循环条件不再为真时，也会执行，是多此一举。**No！No！No！在循环结构中，`break`能够跳出循环**。`break`跳出循环时，循环体的条件判断依旧为真，此时`else`内的代码不会被执行。`else`也通常用来检测循环退出的情况，例如：
```python
day = 0
while day <= 7:
    answer = input("你今天认真学习了吗？")
    if answer != "有":
        break
    day += 1
else:
    print("你已经坚持学习了7天啦~")
```
当回答不再是“有”的时候，就会执行分支内的`break`而跳出循环，且不会执行`else`内的语句。此时就能知道程序已经跳出循环。

#### 循环结构的嵌套
循环结构也能够使用嵌套，也就是一个循环里面还包含着其他循环。通常在实际使用的时候，我们的需求可能需要不止一层循环来实现，需要在循环里面嵌套一个循环来实现。比如说现在我们打印一个九九乘法表：
```python
i = 1
while i <= 9:
    j = 1
    while j <= i:
        print(j,"*",i,"=",j*i,end="/") #end设置每次结束需要打印的字符，这里设置为斜杠，当然自己也可以设置空格等其他的字符
        j += 1
    print() #print()的括号内什么都没有表示 打印一个换行
    i += 1
```
上述代码中，`i`管外层循环，管的是九九乘法表中横排的打印；`j`管内层循环，管的是九九乘法表中竖排的打印。

*再次强调,`break`和`continue`只能作用于所在的循环体，且只能作用于一层循环体。可以尝试如下代码：*
```python
#说明代码：
while True:
    print("这是第一层循环")
    while True:
        print("这是第二层循环")
        answer = input("按1继续")
        if answer == "1":
            break
        print("我还在第二层循环内")
    print("我还在第一层循环")
print("这已经是循环外了")

#实际应用
day = 0
hour = 0
while day <= 7:
    while hour < 8:
        print("我今天一定要坚持学习8个小时")
        hour += 1
        if hour > 1:
            break
    day += 1
print("太棒了，你已经坚持了7天只学习一个小时！")
```
上述的实际应用中，break只跳出了第二层循环，第一层循环`break`管不到。这也证明了`break`只能跳出一层循环。`continue`也是一样的~

#### for循环
语法结构如下：
```python
#示例（仅表示语法结构，代码是不能运行在idle中的）
for 变量 in 可迭代对象：
    statement(S)

#举例
for each in "原来你也玩原神":
    print(each)
```
***可迭代对象**指元素能够被单独提取出来的对象，换言之就是可以用`for`循环遍历的对象。比如字符串、列表、元组、字典等。

***迭代**指对象中每个元素被单独拎出来的这个过程。例如字符串`"原来你也玩原神"`经过迭代后为`原`、`来`、`你`、`也`、`玩`、`原`、`神`。

上述举例的代码中，for循环将后面字符串`"原来你也玩原神"`中的每一个字符提取出来，然后赋值给`each`这个变量，之后再打印出来。

#### ● for循环对等差数列求和
之前说过，for循环是对可迭代对象进行迭代，但是整数不是可迭代对象，如何对数列进行迭代，下面将会介绍。求一个数列的和：求1、2、3、4、5、……、9999、10000这个数列的和。

首先for循环只会对可迭代对象进行迭代，若直接输入整数10000，程序会报错，因此需要其他函数来帮助计算`range()`。
```python
#range()的使用语法（仅表示语法结构，代码是不能运行在idle中的）
range(stop)
range(start,stop)
range(start,stop,step)
```
range()具体是怎么取值的，range的区间是什么样的，现在请运行如下代码：
```python
for i in range(10):
    print(i)
print()
for x in range(11):
    print(x)
print()
for y in range(1,11):
    print(y)
```
根据打印的结果可以知道，range()函数的区间为左闭右开区间，即能取到`start`的值，但是取不到`stop`的值。因此求上述数列时需要将`stop`的值设置到**下一个整数**。再在此基础上进行求和，代码如下：
```python
sum = 0 #定义变量sum
for i in range(1,10001):
    sum += i #对每一项求和
print(sum) #打印结果
```
当然`range()`有`step`的参数，能够对于等差数列求和，例如对3、6、9、12、……、3333、……、99996、99999这个数列进行求和，代码如下：
```python
sum = 0 
for i in range(3,100000,3):
    sum += i
print(sum)
```
如果是一个递减的数列，那么给定参数就需要调整，`start`的值为首项，`stop`的值为末项的小1的整数，另外`step`的值为公差应该变为负数。例如求9、6、3、0、-3、-6、-9、……、-6666、……、-99996、-99999这个数列的和。代码如下：
```python
sum = 0 
for i in range(9,-100000,-3):
    sum += i
print(sum)
```
大家可以尝试把`start`和`stop`的值调换，发现程序无法进行。在`range()`的参数中，如果`step`的值为正，此时前面的`start`的值小于`stop`；如果`step`的值为负，此时前面的`start`的值大于`stop`。

对于其他类型的数列如何求和，会在之后通过函数进行求和~

#### ● for循环寻找合数
合数指那些大于1的自然数中，除了1和本身还能被其他自然数整除的数。例如，找出100以内的合数。

分析一下，对100以内每个数进行计算需要一个循环，每个数也都要进行一次循环除余，因此需要循环的嵌套。代码如下：
```python
for n in range(2,101):
    for i in range(2,n):
        if n % i == 0:
            print(f"其中的一个合数是{n}")
```
以上代码的输出结果就是所有的100以内的合数了。

#### ● for循环寻找素数
素数又称为质数，指那些在大于1的自然数中，除了1和本身，无法被其他自然数整除的整数。例如，找出100以内的素数。

分析一下，和找合数类似，对100以内每个数进行计算需要一个循环，每个数也都要进行一次循环除余，因此需要循环的嵌套。和找素数的逻辑是一样的，除开合数就是素数，那么只要对满足合数的进行抛去就行，即使用`break`和`else`即可，代码如下：
```python
for n in range(2,101):
    for i in range(2,n):
        if n % i == 0:
            break
    else:
        print(f"其中一个素数是{n}")
```
以上代码的输出结果就是所有的100以内的素数了。

## 列表
在python中，我们可以用列表来存储（几乎）所有类型的数据，非常方便。

### 创建列表
创建列表非常简单，只需要使用中括号，多个元素之间用逗号分隔开，同时也可以给列表命名作为一个变量（列表命名也遵循变量命名的原则），下面是随机创建的一个列表来解释如何创建列表：
```python
[1,2,3,4,5]
games = ["原神","Minecraft",2048]
```
列表中的元素可以是任意类型，也可以包含相同的元素。

### 访问列表
#### 一、访问整个列表
用赋值给列表的变量名即可：
```python
games = ["原神","Minecraft",2048]
print(game)
```

#### 二、访问列表中的元素
列表作为一个序列（后面会具体学习），是可以访问列表中的每一个元素，也可以单独访问其中一个元素
#### 1、按顺序访问每一个元素
按顺序访问运用之前学过的`for循环`是非常合适的，和字符串（也是序列）是一样的步骤，代码如下：
```python
games = ["原神","Minecraft",2048]
for each in game:
    print(each)
```
#### 2、访问列表中的一个元素
想要单独访问列表中的一个元素，需要用到**下标索引**来实现。语法如下：
```python
#下标索引的使用语法（仅表示语法结构，代码是不能运行在idle中的）
列表名[下标索引值]
#示例
games[0]
```
**需要注意的是列表中第一个元素的下标索引值为0，第二个元素的下标索引值为1，以次类推**，下面可以尝试如下代码：
```python
a = ["我是第一个元素","我是第二个元素","我是第三个元素"]
print(a[0],a[1],a[2])
```
上述的例子就可以看出列表的第一项下标索引值为0。其实，其他可以使用下标索引的都是这样，下标索引值是从0开始排的。

如果一个列表的元素特别多，导致根本不知道最后一个元素的下标索引值是多少，这个时候需要知道的是下标索引值是可以为负数。容易想象的是，负数就是倒过来排序。需要也注意的是，**如果需要用负的下标索引值来表示最后一个元素，这个时候不是以0开始，而是-1开始，那么倒数第二个就是-2，以此类推**。可以尝试如下代码来验证：
```python
a = ["我是第一个元素","我是第二个元素","我是第三个元素"]
print(a[-1])
```

### 列表切片
有时候我们需要一次性获取多个元素，但不是整个列表。为了满足这个需要，在python中支持切片这一语法。甚至因为切片才导致下标索引值要从0开始。
>在Python中，列表、元组和字符串等序列类型的索引从0开始，这一设计源自于Python的前身语言C语言。 在C语言中，数组的第一个元素的内存地址被视为数组名本身，因此数组元素的内存地址可以通过基地址加上元素的偏移量来计算。 具体而言，第n个元素的内存地址可以通过基地址加上n乘以元素大小来计算。 这种设计使得从0开始的索引与内存地址的计算方式相一致，简化了内存寻址的过程。 Python作为受C语言影响的语言，继承了这一设计。 此外，Python的创始人Guido van Rossum指出，使用从0开始的索引可以使切片操作更加优雅。例如，使用半开区间切片时，a[:n]表示取前n个元素，而a[i:i+n]表示从第i个元素开始取n个元素，这种写法简洁且直观。 
>
>综上所述，Python采用从0开始的索引方式，既是为了与C语言保持一致，也是为了简化内存地址计算和切片操作。
>
>——ChatGPT

切片语法只需要用下标索引值的范围表示要提取元素的范围就可以了。具体语法如下：
```python
#切片的使用语法（仅表示语法结构，代码是不能运行在idle中的）
列表名[start:stop:step]

#示例
games = ["原神","Minecraft",2048,"Genshin Impact","扫雷","纸牌","植物大战僵尸","猫国建设者"]
print(games[0:7])
print(games[0:8])
print(games[1:3])
print(games[0:4:1])
print(games[:3])
print(games[2:])
print(games[::-1])
```
切片也支持输入三个参数。`start`和`stop`输入的参数也遵循**左闭右开**，第一行和第二行打印出来的结果只相差最后一个元素，最后一个元素的下标索引值为7。当未给出`start`或`stop`的值时，默认取到从头或最后，非常的方便。`step`参数也支持输入负数，当其值为`-1`时，会将整个列表翻转一次，也可以是`-2`则在翻转的基础上再隔一个取一个。

### 列表的添加
只要我们想，就可以随时地想列表中添加元素。
#### append()方法
我们可以使用`append()`方法将想要添加的元素添加进列表的末尾，具体语法如下：
```python
#append()的使用语法（仅表示语法结构，代码是不能运行在idle中的）
列表名.append(添加的东西)

#示例
games = ["原神","Minecraft",2048,"Genshin Impact","扫雷","纸牌","植物大战僵尸","猫国建设者","多邻国"]
games.append("黑神话：悟空")
```
`append()`方法虽然方便，但是有一个缺点是每次只能添加一个元素。
#### extend()方法
`extend()`方法可以添加很多的元素，它能够运行我们添加一个**可迭代对象**。输入的元素会被迭代，想要输入想要的词组，可以输入一个列表。添加之后的元素还是加在列表的最后面。还是用上面的列表举例，使用语法如下：
```python
#extend()的使用语法（仅表示语法结构，代码是不能运行在idle中的）
列表名.extend(可迭代对象)

#示例
games.extend(["星露谷物语","it takes two"])
games.extend(["星露谷物语"])

#错误的代码
games.extend("星露谷物语","it takes two")  #语法不对
games.extend("星露谷物语") #输入的内容被迭代，表达不了原来的意思
```
#### 切片方法
python以切片为傲，也能够使用切片添加元素。和`extend()`方法一样，添加的元素也只能是可迭代对象，且被添加时会被迭代，且放在列表的最后。还是用上面的列表举例，使用语法如下：
```python
#切片方法的使用语法（仅表示语法结构，代码是不能运行在idle中的）
列表名[len(列表名):] = 可迭代对象  #len()函数获取列表的长度

#示例
games[len(game):] = ["goose goose duck","over cooked!"]
```
这个方法不容易检查，不太能够简单的理解出来这是在干什么，不是很推荐这种添加方法。说了这么多，还是没有一个方法可以在列表中间添加元素
#### insert()方法
`insert()`方法可以在列表里面想要的位置添加元素。该方法对于添加的元素类型没有太多的要求，添加整数，字符串，浮点数，列表都可以，**但是有一个缺点是每次只能添加一个元素**。和上述添加可迭代对象的方法不同的是，该方法不会对可迭代对象进行迭代。还是用上面的列表举例，使用语法如下：
```python
#insert()方法的使用语法（仅表示语法结构，代码是不能运行在idle中的）
列表名.insert(希望被添加元素所在的下标索引值,添加的元素)

#示例
games.insert(2,"我的世界")
games.insert(4,["绝区零","崩坏"])
```
若输入的下标索引值为`0`则总是插入在列表的开头，如果是`len()`则总是插在列表的末尾。

### 列表的删除
#### remove()方法
如果要删除列表中指定的一个元素时，可以使用`remove()`方法。使用起来非常简单，继续用上面的列表举例，使用语法如下：
```python
#remove()方法的使用语法（仅表示语法结构，代码是不能运行在idle中的）
列表名.remove(需要删除的对象)

#示例
games.remove("多邻国")
```
**需要注意的是，如果列表中存在多个匹配的元素，只会删除第一个匹配的元素；如果被指定的元素不存在，程序会报错**
#### pop()方法
`pop()`方法输入的参数是元素的下标索引值，每次只能输入一个参数。一样的使用起来非常简单，继续用上面的列表举例，使用语法如下：
```python
#pop()方法的使用语法（仅表示语法结构，代码是不能运行在idle中的）
列表名.pop(被删除元素的下标索引值)

#示例
games.pop(4)
```

#### clear()方法
`clear()`方法可以使列表中的元素全部清空，使其变为一个空列表。一样的使用起来非常简单，继续用上面的列表举例，使用语法如下：
```python
#clear()方法的使用语法（仅表示语法结构，代码是不能运行在idle中的）
列表名.clear()

#示例
games.clear()
```

### 列表的替换
列表和字符串最大的区别是，列表可以修改其中某一个元素，而字符串是不可变的。替换列表中某一个元素和访问列表类似，都是使用列表中元素的下标索引值进行确定元素，然后用赋值运算符将新的元素进行赋值进去完成替换。
#### 替换单个元素
对于替换单个元素，具体语法如下：
```python
#使用语法（仅表示语法结构，代码是不能运行在idle中的）
列表名[被替换元素的下标索引值] = 新的元素

#示例
games = ["Minecraft","it takes two","Fall Guys","原神","Plants VS zambies"]  #创建一个列表
games[3] = "Genshin Impact"
games[games.index("原神")] = "Genshin Impact"  #index()用来获取元素的下标索引值，后面会讲
```
#### 替换多个元素
切片是python引以为傲的功能。如果要替换多个元素，可以用切片来实现。注意的是，此方法新替换的元素也应该是可迭代对象，且替换时会对该对象进行迭代。和之前的添加方法不同的是，该方法支持添加多个可迭代对象，添加时不会对对象进行迭代。注意继续用上面的列表举例，使用语法如下：
```python
#使用语法（仅表示语法结构，代码是不能运行在idle中的）
列表名[start:stop:step] = 新的可迭代对象

#示例
games[1:] = ["Minecraft:Java Editon","Minecraft:Bedrock"]
games[1:] = "Minecraft:Java Editon","Minecraft:Bedrock"
```

### 列表的排序
#### sort()方法
想要对一个列表（下面以全数字的列表举例，字符串的列表也可以排序，但是字符串列表是根据第一个字符的ASCII编码排序）进行**从小到大**排序，除了运用排序函数，python提供了一个非常简单的方法——`sort()`方法。语法如下：
```python
#sort()的使用语法（仅表示语法结构，代码是不能运行在idle中的）
列表名.sort(key=none,reverse=false) #key和reverse是两个参数，初学者可以先不用去管它

#示例
nums = [3,5,6,4,9,5,3,2,1,7] 
nums.sort()
```
#### reverse()方法
想要对一个列表进行**从大到小**排序，除了运用排序函数，python提供了一个非常简单的方法——`resort()`方法。和`sort()`方法的使用语法差不多，继续用上述的列表举例，语法如下：
```python
#reverse()的使用语法（仅表示语法结构，代码是不能运行在idle中的）
列表名.reverse()

#示例
nums.reverse()
#sore()方法添加reverse参数也是一样的效果
nums.sort(reverse=Ture)
```

### 列表的查找
#### count()方法——查找个数
如果想要对列表中的一个元素计数，python提供了一个方法，可以直接对其定的对象进行计数——`count()`方法。语法如下：
```python
#count()的使用语法（仅表示语法结构，代码是不能运行在idle中的）
列表名.count(要查询的对象)

#示例
nums = [3,5,6,4,9,5,3,2,1,7,5,4,9,8,2,1,5,4,1,5,4,7,6,3,6,9,7,1,1,5,7,2,2,6,4,7,9,6,4,1,6,3] 
nums.count(5)
```
#### index()方法——查找下标索引值
查找下标索引值可以使用`index()`来查询。若不给其他参数下，默认给出下标索引值最小的哪一个对象的下标索引值，因此该方法每次只能查询一个对象。用上面的列表举例，用法如下：
```python
#index()的使用语法（仅表示语法结构，代码是不能运行在idle中的）
列表名.index(查找的对象,start,stop)

#示例
nums.index(3)
nums.index(3,5,20)
```
**● 运用index()方法替换列表中的元素**
当我们需要替换列表中的元素但是不知道该元素的下标索引值，此时就可以与`index()`方法合用，之前替换的时候出现过一次。具体代码如下：
```python
#使用语法（仅表示语法结构，代码是不能运行在idle中的）
列表名[列表名.index(被替换的对象,start,stop)] = 新的对象

#示例
games = ["Minecraft","it takes two","Fall Guys","原神","Plants VS zambies"]  #创建一个列表
games[games.index("原神")] = "Genshin Impact"  
```

### 列表的计算
在python中，列表也是有加法和乘法，另外列表本身不支持直接进行减法或除法操作。
#### 列表的加法
列表的加法其实就是对列表拼接，当然的要求加号两边都应该是列表。语法如下：
```python
#使用语法（仅表示语法结构，代码是不能运行在idle中的）
列表 + 列表

#示例
a = [1,2,3]
b = [4,5,6]
a + b
```
上述的例子输出的结果就是将两个列表拼接起来。除了列表里面的元素是整数，也可以是其他类型的元素，其最后输出的结果也是将两个列表进行拼接。

#### 列表的乘法
**要求一个列表与整数相乘**，列表和列表不能直接相乘。意义就是将这个列表里面的元素重复几次。语法如下：
```Python
#使用语法（仅表示语法结构，代码是不能运行在idle中的）
列表 * int

#示例
a = [1,2,3]
a * 3
```
查看返回的结果，一个列表与整数相乘，意义就是将这个列表里面的元素重复几次。

### 嵌套列表——二维列表
嵌套列表就是在列表里面再包含列表，同时也叫**二维列表**。二维列表在数学中最主要的运用就是**矩阵（matrix）**，它广泛运用在计算机图形学，深度学习，机器人开发，无人驾驶等领域。
#### 创建嵌套列表
下面是一个实际例子演示如何创建一个二维列表：
```python
a = [[1,2,3],[,4,5,6],[7,8,9]]
b = [[1,2,3],
     [4,5,6],
     [7,8,9]]
```
例子中的两种写法是等价的，`b`的写法有一个好处就是更直观，相当于是二维即一个平面。另外还可以使用循环语句或者列表推导式（后续会学习）来创建并初始化二维列表，代码如下：
```python
#for循环
A = [0] * 3
for i in range(3):
    A[i] = [0] * 3

#列表推导式
w, h = 3, 3
A = [[None] * w for i in range(h)]

#严禁使用：以下是大错特错的代码
A = [[0] * 3] * 3
```
上面的原理是通过对已有的列表进行元素的替换。*特别注明：严禁使用直接对已有列表进行相乘的方法!!!*先说结论，这样创建出的列表并不是每个元素独立的列表，具体为什么后面在“列表的拷贝”中解释。

#### 访问嵌套列表
**访问所有元素**
循环访问一维列表，用的是`for`一层循环；访问嵌套列表固然需要嵌套循环。下面以一个例子来介绍访问嵌套列表中所有元素的代码：
```python
matrix = [[1,2,3],
          [4,5,6],
          [7,8,9]]
#对嵌套列表中所有包含的元素单个打印
for i in matrix:
    for each in i:
        print(each)

#对嵌套列表中内嵌列表分开打印
for i in matrix:
    for each in i:
        print(each,end=" ")
    print()
```

**访问内嵌列表**
嵌套列表中的内嵌列表本质也是外层列表的一个元素，用一维列表访问元素的方式也能在嵌套列表中实现访问内嵌列表，用上面的列表举例：
```python
#使用语法（仅表示语法结构，代码是不能运行在idle中的）
列表名[内嵌列表下标索引值]

#示例
matrix[1]
matrix[0]
```

**访问内嵌列表中的元素**
上面说过了内嵌列表的访问方法，`matrix[]`指代的是内嵌列表，那么内嵌列表的元素怎么访问就不言而喻了。所以访问内嵌列表中的元素就是用两次下标索引就可以了，继续用上述的列表举例，代码如下：
```python
#使用语法（仅表示语法结构，代码是不能运行在idle中的）
列表名[内嵌列表下标索引值][访问元素的下标索引值]

#示例
matrix[1][1]
matrix[2][0]
```
之前说，嵌套列表是一种二维列表，上面的访问方法就能很好的表示它的二维：第一个`[]`索引的是二维列表的行；第二个`[]`索引的是二维列表的列。


### 列表的拷贝（复制）
列表的拷贝分为浅拷贝和深拷贝，既然分为两个单独的拷贝方式，肯定是有不一样的地方。
#### 一、浅拷贝
浅拷贝指的是创建一个新的对象，但这个新对象的内容是**原对象的引用，而不是原对象内容的复制**。这意味着，浅拷贝的对象包含的是原对象中元素的引用，而不是这些元素本身的副本。这具体会影响什么，我们之后会提到并且演示。

#### copy()方法
`copy.()`是典型的一个**浅拷贝**的方法，作为最基础的一种复制方式，其使用起来也是非常简单。使用代码如下：
```python
#copy()使用语法（仅表示语法结构，代码是不能运行在idle中的）
新的列表名 = 被复制的列表名.copy()

#示例
games = ["Minecraft","it takes two","Fall Guys","原神","Plants VS zambies"]
games_copy1 = games.copy()
```

#### 切片方法
切片也是可以实现**浅拷贝**的效果。以上面的例子举例，具体操作如下：
```python
#切片使用语法（仅表示语法结构，代码是不能运行在idle中的）
新的列表名 = 被复制的列表名[:]

#示例
games_copy1 = games[:]
```

#### 浅拷贝的实质
介绍浅拷贝时说过，浅拷贝只是单单对目标对象的**引用（即指针）**。为了解释清楚这个问题，现在先需要引入一个新的运算符`is`运算符。`is`运算符用来比较两边的对象是不是同一个对象，即它们是否指向内存中的同一块地址。下面尝试如下代码：
```python
x = "Nanjing"
y = "Nanjing"
x is y

a = [1,2,3]
b = [1,2,3]
a is b
```
尝试之后发现`x is y`返回的值是`True`，而`a is b`返回的值却是`False`。一组是字符串，一组是列表，结果却完全相反。

**原因解释**这和python的内存管理方式有关。字符串是不能变的，如果有多个变量名均被赋值为同一个字符串，那么python就只将该字符串放在一个内存中储存，且当赋值给其他变量时只对其进行引用（即指向，重复赋值内存地址）即可。而列表是可变的，python并不能知道用户在后续会不会对列表进行改变，那么为了不引起冲突，就会将每个列表单独放在一个内存中。之前在创建二维列表中说到**严禁使用**的方法也是因为这个原因，看似也创建了一个二维列表，实际上内嵌列表互相干扰，并不是一个独立的存在。
![字符串存储](./image/字符串存储.png)
![列表存储](./image/列表存储.png)

了解了这些之后，就可以看看浅拷贝和之前的**严禁使用的方法**会有什么区别了。尝试如下的代码：
```python
#浅拷贝
matrix = [[0,0,0],[0,0,0],[0,0,0]] 
matrix_copy = matrix.copy()
matrix[1][1] = 3
print(matrix_copy)
print(matrix)

#使用乘法创建二维列表【严禁使用】
A = [[0] * 3] * 3
A[0][1] = 1
print(A)
```
浅拷贝中发现更改原列表的数值，复制列表跟着改变；乘法创建二维列表中，更改了其中一个内嵌列表的值，其他的内嵌列表也跟着改变。既然现在也有`is`运算符，可以对其进行比较：
```python
#浅拷贝
matrix_copy is matrix
matrix_copy[0] is matrix[0]
matrix_copy[1] is matrix[1]
matrix_copy[2] is matrix[2]
matrix_copy[1] is matrix[2]

#使用乘法创建二维列表【严禁使用】
A[0] is A[1]
A[1] is A[2]

#一个正常的二维列表
matrix = [[0,0,0],[0,0,0],[0,0,0]]
matrix[0] is matrix[1]
matrix[1] is matrix[2]
matrix[0] is matrix[2]
```
通过`is`运算符确定了浅拷贝对内嵌列表只是做了一个引用，外面的列表则是在复制赋值时创建的一个新列表。相乘创建的二维列表则是对`[0,0,0]`这个列表的引用若干次。
![浅拷贝存储1](./image/浅拷贝储存.png)
![相乘创建二维列表存储](./image/相乘创建二维列表存储.png)

通过上述的解释，浅拷贝只是拷贝的对一个列表的引用，相乘创建二维列表实际上是对同一个列表的引用的拷贝。这些现象在python的官方文档中是写清楚了的
> 2.Values of n less than 0 are treated as 0 (which yields an empty sequence of the same type as s). Note that items in the sequence s are not copied; they are referenced multiple times. This often haunts new Python programmers; consider:
>```python
>>>> lists = [[]] * 3
>>>> lists
> [[], [], []]
>>>> lists[0].append(3)
>>>> lists
> [[3], [3], [3]]
>```
> What has happened is that [[]] is a one-element list containing an empty list, so all three elements of [[]] * 3 are references to this single empty list. Modifying any of the elements of lists modifies this single list. You can create a list of different lists this way:
>```python
>>>> lists = [[] for i in range(3)]
>>>> lists[0].append(3)
>>>> lists[1].append(5)
>>>> lists[2].append(7)
>>>> lists
>[[3], [5], [7]]
>```

前面的是浅拷贝，既然浅拷贝有这些特点，有深有浅，那就会有深拷贝。

#### 二、深拷贝
与浅拷贝不一样的是，深拷贝能够使被拷贝的对象真正拷贝到内存中一块新的地方，和原来的对象完全独立。我们可以用图像来解释：
![深拷贝储存](./image/深拷贝储存.png)
要实现深拷贝，需要借助python自带的copy模块，同样的也需要手动导入。该模块有两个函数，一个是`copy()`实现的是浅拷贝，另一个是`deepcopy()`实现的是深拷贝。和前面的`copy()`方法的使用不一样，该函数的使用需要指定模块和对象。下面是创建一个列表，对其进行深拷贝的代码：
```python
#copy模块的使用语法（仅表示语法结构，代码是不能运行在idle中的）
新变量名 = copy.函数名(被拷贝变量名)

#以下是示例，先创建一个二维列表
A = [0] * 3
for i in range(3):
        A[i] = [0] * 3

#copy模块copy函数：实现浅拷贝
B = copy.copy(A)
A[1][1] = 5
print(A)
print(B)

#copy模块deepcopy函数：实现深拷贝（操作前对二维列表A进行重置）
C = copy.deepcopy(A)
A[1][1] = 5
print(A)
print(C)
```
虽然深拷贝有很多有点，但是相较于浅拷贝来说，深拷贝的效率远不及浅拷贝，而python语言很注重代码的效率，所以python默认对对象做的是浅拷贝。

#### 三、浅拷贝与深拷贝
在python的官方文档中对浅拷贝和深拷贝做了一个比较，列出了一些用浅拷贝和深拷贝的情景：
> The difference between shallow and deep copying is only relevant for compound objects (objects that contain other objects, like lists or class instances):
> + A shallow copy constructs a new compound object and then (to the extent possible) inserts references into it to the objects found in the original.
> + A deep copy constructs a new compound object and then, recursively, inserts copies into it of the objects found in the original.
>
> Two problems often exist with deep copy operations that don’t exist with shallow copy operations:
> + Recursive objects (compound objects that, directly or indirectly, contain a reference to themselves) may cause a recursive loop.
> + Because deep copy copies everything it may copy too much, such as data which is intended to be shared between copies.
>
> The `deepcopy()` function avoids these problems by:
>+ keeping a memo dictionary of objects already copied during the current copying pass; and
>+ letting user-defined classes override the copying operation or the set of components copied.

### 列表推导式
列表推导式是列表中非常~~牛~~厉害的一个东西，具体为什么是这样的，先引入一个题目：将整数列表中每一个元素的值变为原来的两倍。最开始一定会想到循环，通过下标索引对每个元素乘以二的操作：
```python
nums = [1,2,3,55,44,4,5]
for i in range(len(nums)):
    nums[i] = nums[i] * 2
```
但是列表推导式并不用这么麻烦，对于成倍扩大的操作可以用一行代码即可完成：
```python
nums = [1,2,3,55,44,4,5]
nums = [i * 2 for i in nums]
```
这就是列表推导式。从程序执行效率上来说，列表推导式比循环执行的效率会快上一倍（**原因**列表推导式在Python解释器中是以更快的C语言的速度来运行的，而for循环是在python脚本的pvm虚拟机中以步进的速度来运行的，从运行方式上就能看出来列表推导式的效率比循环会快很多）。这就是列表推导式的厉害之处。列表推导式具体怎么用，接下来会详细说明。

首先是构建语法：列表推导式是列表需要表示列表的`[]`；列表推导式的结果是使用一组数据来填充这个列表，所以需要一个for语句来搭配；最后在for语句的左侧放了一个表达式，相当于循环体，经过运算才决定存放在列表中的数据
```python
#列表推导式的使用语法（仅表示语法结构，代码是不能运行在idle中的）
[expression for target in iterable]

#示例
x = [i for i in range(10)] #创建一个0~9的列表
y = [i + 1 for i in range(10)] #创建一个1~10的列表
```
循环也能做到上面的效果，但是就像之前说的，循环的效率不及列表推导式
```python
x = []
y = []
for i in range(10):
    x.append(i)
    y.append(i+1)
```
除了整数，for循环能迭代所有可迭代对象，下面以字符串为例。对字符串迭代的同时乘以倍数，就是重复这个字：
```python
a = [c * 2 for c in "简单"] #a列表变为 “简简单单”
```
列表推导式也可以很方便地将字符串中的文字转换成编码存储（这只是来熟悉列表推导式的用法的）。将文字转换成编码需要用到`ord`函数：
```python
code = [ord(i) for i in "简简单单"] 
```
增加一点难度，二维列表可以是一种矩阵。用列表推导式也可以将二维列表的某一列提取出来：
```python
matrix = [[1,2,3],
          [4,5,6],
          [7,8,9]]
col2 = [row[1] for row in matrix]
```
这个时候col2就是这个二维列表第二列的三个元素。分析一下代码：通过for函数获取每一行的列表存放到`row`这个列表里，再通过下标索引获取第二个元素存放到`col2`中。了解了这些之后，我们也可以获取从左上角到右下角这条对角线上的元素，继续用上述的列表举例：
```python
diag = [matrix[i][i] for i in range(len(matrix))]
```
这样就可以将从左上到右下的对角线上的元素提取出来。分析一下代码：这一次我们不是提取的元素，而是提取的元素的下标索引值。另外地，我们也可以提取从右上角到左下角的元素，继续用上述的列表举例 **（可以先不看下面的代码，自己尝试一下）**：
```python
diag1 = [matrix[i][-i-1] for i in range(len(matrix))]
```
这样就可以提取从右上角到左下角的对角线上的元素了。分析一下代码：和获取从左上角到右下角这条对角线上的元素一样是获取的下标索引值，再我们需要第一个内嵌列表的第三个元素，这个元素除了`2`这个下标索引值之外还有`-1`，之后每一项都满足`-i-1`这个式子，故提取出来的就是从右上角到左下角的对角线上的元素了。

+ **循环和列表推导式的区别**是循环是在原来存在的列表里面添加东西，而列表推导式则是创建一个列表的同时往里面加东西

之前在创建二维列表时提过可以用列表推导式创建：
```python
w, h = 3, 3
A = [[None] * w for i in range(h)]
```
这也是一样的效果。

#### 列表推导式和分支结构
其实列表推导式还可以添加一个用于筛选的if分句。后面的if分句用来筛选前面for循环的结果，如果满足条件就会被放在最前面的表达式中，然后继续下一个for循环；如果不满足条件就会被舍弃，然后继续下一个for循环。语法如下：
```python
#使用语法（仅表示语法结构，代码是不能运行在idle中的）
[expression for target in iterable if condition]

#示例
even = [i for i in range(10) if i % 2 == 0]  #创建一个9内的偶数的列表
```
到这里应该会有疑问，在这种列表推导式中，到底是先运行后面的if条件筛选，还是先运行前面的表达式？想要证明这个问题很简单，只需要将前面的表达式修改一下，然后再看结果是什么即可：
```python
even = [i + 1 for i in range(11) if i % 2 == 0]
```
结果是`1,3,5,7,9`，事实上证明列表推导式是先执行for语句，再执行if语句，最后再执行最左侧的表达式。

现在知道了列表推导式可以添加条件判断语句，就可以筛选一些元素了。例如，在
"apple", "book", "cat", "dog", "elephant", 
"flower", "green", "house", "island", "juice", 
"kite", "lemon", "moon", "nest", "orange", 
"park", "queen", "rose", "sun", "tree",
"ant", "ball", "car", "duck", "egg", 
"fish", "grape", "hill", "ice", "jam", 
"king", "lamp", "man", "net", "octopus", 
"pen", "queen", "ring", "star", "tiger", 
"umbrella", "vase", "window", "xylophone", "yarn", 
"zebra", "air", "baby", "cloud", "dance"
中找出单词开头为"c"的单词，并放入列表中。
```python
words = [
    "apple", "book", "cat", "dog", "elephant", 
    "flower", "green", "house", "island", "juice", 
    "kite", "lemon", "moon", "nest", "orange", 
    "park", "queen", "rose", "sun", "tree",
    "ant", "ball", "car", "duck", "egg", 
    "fish", "grape", "hill", "ice", "jam", 
    "king", "lamp", "man", "net", "octopus", 
    "pen", "queen", "ring", "star", "tiger", 
    "umbrella", "vase", "window", "xylophone", "yarn", 
    "zebra", "air", "baby", "cloud", "dance"
]
c_words = [c for c in words if c[0] == "c"]
```
这样就找出了c开头的单词。分析一下代码：新建一个`words`列表，放入所有的单词，用列表推导式将`words`中的单词放入`c`中存放，再用下标索引提取放入`c`的单词的第一个字符，之后和`"c"`比较，若相同则将`c`放入`c_words`中，不是则进入下一个循环。

#### 列表推导式的嵌套
和列表一样，列表推导式也能嵌套。语法如下：
```python
[expression for target in iterable
            for target in iterable1
            for target in iterable2
            ...
            for target in iterableN]
```
而列表推导式的嵌套可以对二维列表实现降维，即把所有内嵌列表中的元素全部提取出来。代码如下：
```python
matrix = [[1,2,3],[4,5,6],[7,8,9]] #创建一个二维列表
flatten = [col for row in matrix for col in row]
```
分析一下代码：第一个`for`做的是将内嵌列表放入`row`中，第二个`for`做的是将先前放入`row`的列表中的元素一个一个提取出来放入`col`中，最后得到一个一维列表。将它转换为`for`循环的形式为（可以自己尝试一下，先不看下面的代码）：
```python
flatten = []
for row in matrix:
    for col in row:
        flatten.append(col)
```
上面的循环可以做到和之前的列表推导式一样的效果。同时观察for循环的代码和列表推导式，在列表推导试中，外层循环放在前面，内层循环放后面。

在数学中有一个叫笛卡尔乘积的东西，让ChatGPT帮你解答什么是笛卡尔乘积：
>笛卡尔乘积（Cartesian product）是数学中的一个概念，指的是两个集合A和B的所有可能的有序对（a, b），其中a属于A，b属于B。笛卡尔乘积的结果是一个新的集合，它包含了A和B的所有可能的组合。
>### 形式化定义
>假设A和B是两个集合，笛卡尔乘积A × B定义为：
>$$ A×B={(a,b)∣a∈A,b∈B} $$
>这表示A × B中的元素是所有可能的（a, b）形式的有序对，其中a来自A，b来自B。
>### 举个例子
>假设有两个集合：
>+ A = {1, 2}
>+ B = {x, y}
>那么A × B的笛卡尔乘积就是：
>$$ A×B={(1,x),(1,y),(2,x),(2,y)} $$
>可以看到，笛卡尔乘积是通过组合A中的每个元素与B中的每个元素，得到的所有有序对。
>### 进一步拓展
>如果你有多个集合，比如A, B, C，那么笛卡尔乘积就可以是A × B × C，表示所有来自A、B、C的有序三元组。
>
>比如，如果C = {p, q}，那么：
>$$ A×B×C={(1,x,p),(1,x,q),(1,y,p),(1,y,q),(2,x,p),(2,x,q),(2,y,p),(2,y,q)} $$
>笛卡尔乘积广泛应用于数据库（如关系型数据库中的表），以及很多数学和计算机科学的领域。
列表推导试的嵌套就可以实现类似的效果：
```python
a = "abc"
b = "xyz"
c = [m + n for m in a for n in b]
```

#### 列表推导式的嵌套和分支结构
像普通的列表推导式后能接分支结构一样，嵌套的列表推导式也能在每一条for语句后面加上if条件判断句进行条件筛选。总的来说，列表推导式最终的语法结构应该如下：
```python
[expression for target1 in iterable1 if condition1
            for target2 in iterable2 if condition2
            for target3 in iterable3 if condition3
            ...
            for targetN in iterableN if conditionN]
```
有点复杂，举一个例子，找出横纵坐标都在10以内的横坐标能被2整除，且纵坐标能被3整除的点。（可以先自己试试，不看下面的代码）：
```python
#列表推导式
dot = [(x,y) for x in range(11) if x % 2 == 0 for y in range(11) if y % 3 == 0]

#循环
dot = []
for x in range(11):
    if x % 2 == 0:
        for y in range(11):
            if y % 3 == 0:
                dot.append((x,y))
```

**列表学了这么多，有很多方法能够做到相同的效果，但是写程序最主要看重的是简单，写法简单，理解简单，维护简单**

## 元组
元组是像列表那样同时能容纳多个对象，也有像字符串那样不可变的特性。

### 创建元组——元组的打包
创建元组我们有的时候会被成为元组的打包。如何创建一个元组，从语法上看，元组与列表的区别是列表用的方括号`[]`，元组用的是小括号`()`
```python
games = ("原神","Minecraft","2048","Among us","Plants VS zambies","崩坏：星穹铁道")
```
事实上，元组可以不用带括号
```python
games = "原神","Minecraft","2048","Among us","Plants VS zambies","崩坏：星穹铁道"
```
这样也能创建一个元组。

如果想要创建只有一个元素的元组，需要在元素后面添加一个`,`来表示这是元组：
```python
a = (520) #创建的是一个 int
type(a)

b = (520,) #创建一个元组
type(b) 
```
### 访问元组
和列表等变量一样，访问元组也是通过赋值给它的变量名访问，用上面的`games`元组举例：
```python
print(games)
```
另外访问元组中的元素也是和列表一样，用下标索引值。元组的下标索引值和列表也是一样的：
```python
print(games[0]) #访问第一个元素
```

### 元组的修改
介绍元组时候说过，**元组是不可变的**，如果对元组进行访问下标索引值然后**进行修改程序会报错**。但有一种情况例外，元组内指向了一个可变的列表。换句话就是说元组内包含了一个可变的列表，且这个列表是被引用进了元组：
```python
a = [1,2,3]
b = [4,5,6]
w = (a,b)
w[0][0] = 0
```
这是元组中唯一可变的情况。

### 元组的切片
切片是将元组中特定的元素用特定的方式（比如传入的参数`start`，`stop`，`step`）导出，而非修改元组本身。元组的切片语法和列表是一样的
```python
games[:1]
games[:]
games[::2]
games[::-1]
```
### 元组的查找
因为元组具有不可变的特性，所以元组只有`count()`方法和`index()`方法。这两种的使用方法**和列表是完全一样的**：
```python
nums = (1,5,2,6,9,4,1,2,5,6,3,4,9,7,5,1,2,5,4,2,5,4,2,9,7,6,8,4,3,5,9,4) #创建一个元组
nums.count(5) #数出元组中有多少个5

games = ("原神","Minecraft","2048","Among us","Plants VS zambies","崩坏：星穹铁道")
games.index("2048") #获取"2048"的下标索引值
```

### 元组的计算
元组是有加法和乘法的（*注意元组本身不可变，进行运算之后是生成的一个新元组*），也和列表是完全一样的：
```python 
a = (1,2,3)
b = (4,5,6)
print(a+b)
print(a * 3)
```

### 元组的嵌套
元组和列表一样也支持嵌套，和列表的操作方式一样：
```python
a = (1,2,3)
b = (4,5,6)
w = a,b
```

### 元组的迭代
元组也是一个可迭代对象，可迭代对象就能使用for循环：
```python
nums = (1,5,2,6,9,4,1,2,5,6,3,4,9,7,5,1,2,5,4,2,5,4,2,9,7,6,8,4,3,5,9,4)
for each in nums:
    print(each)
```

### 元组的转化
元组可以通过列表推导式转换成列表（当然也可以使用for循环）：
```python
nums = (1,5,2,6,9,4,1,2,5,6,3,4,9,7,5,1,2,5,4,2,5,4,2,9,7,6,8,4,3,5,9,4)
nums_list = [i for i in nums]
```
**特别注意**没有元组推导式这个东西！！！但是是可以将列表推导式的方括号变为圆括号，但最后输出的是一个生成器：
```python
nums = (i for i in range(11)) 
```
不出意外的会生成一个`<generator object <genexpr> at 0x什么什么的>`这个形式的东西就是一个生成器，后面会说明。


### 元组的解包
前面说过元组的打包，现在是元组的解包。将元组中的元素一次性赋值给多个变量名称之为元组的解包。通过一个示例来表示语法：
```python
#使用语法（仅表示语法结构，代码是不能运行在idle中的）
变量名 = 元组名

#示例
nums = (520,1314,3.14)
x , y ,z = nums
```
这种方法也可以用于列表，字符串等的解包：
```python
#列表
nums = [520,1314,3.14]
x , y ,z = nums
#字符串
a, b, c, d, e = "apple"
```
**不管对哪一类型的解包，必须满足左边的变量名和右边元素数量保持一致，否则会报错。**如果只需要前面若干个字符，后面的字符不需要时，可以在最后面的变量前加上`*`，例如：
```python
nums = (1,5,2,6,9,4,1,2,5,6,3,4,9,7)
a,b,c,*d = nums
```
在一开始学习给变量赋值的时候学过一个方法就是——多重赋值，当时提到过是通过元组实现的：
```python
x,y = 1,2

#实现逻辑
_ = (1,2)  #无关紧要的变量可以用"_"代替
x,y = _
```
实现的逻辑就是先通过元组将后面的数值进行打包，再通过解包将值赋值给前面的变量名。

## 字符串（终章）
重新理解字符串，字符串是像元组那样的一种序列，序列有一个特点就是不可变。所以现在知道字符串有可迭代，不可变的特性。
### 字符串的切片
字符串也是序列，那么就支持切片，想要将一个字符串倒转切片就很容易实现。例如寻找1000以内的回文数，回文数指将一个数倒过来写之后还和原来一样就是回文数：
```python
for i in range(1001):
    _ = str(i)  #无关紧要的变量可以用"_"代替
    if _ == _[::-1]:
        print(f"{i}是一个回文数")
```
分析一下代码，for循环获取整数，通过`str`方法将整数转换成为字符串存储在变量`_`中，然后通过if条件判断句判断原来的数`_`和翻转之后的数做比较，如果一样则输出，不一样就进入下一次循环。

### 字符串的各种方法
以下来源python的官方文档，可能会有出入
+ 尽请期待

用这些方法能够让代码运行更快，因为是运用封装在python中的c语言来编写，同时也能够让代码更安全。
### 字符串的大小写转换
在python中自带有6种方法可以实现字符串的大小写转换，每种方法都有独特的用处。另外也由于我们的母语不是英语，这些方法会显得有些多余。**需要注意的是**字符串是不可变的对象，每一种变换方法之后是根据方法的规则生成的一条新字符串，不是原来的字符串。
#### `capitalize()`方法
该方法可以将字符串的首字母变为大写并返回新的字符串，其他字母变为小写。例如：
```python
x = "I love studying Python"
x.capitalize()
print(x) #原字符串没有做任何改变
print(x.capitalize()) #返回新的字符串
```
#### `casefold()`方法
该方法可以将字符串中的所有字母变为小写，然后返回新的字符串。例如：
```python
x = "I love studying Python"
x.casefold()
```
+ 根据官方文档的提示，该方法与下方的`lower()`方法不一样的是该方法能够处理除英语之外的其他语言
#### `title()`方法
该方法将字符串中每个单词的首字母大写,其他字母变成小写，然后返回新的字符串。例如：
```python
x = "I love studying Python"
x.title()
```
#### `swapcase()`方法
该方法将字符串中所有字母的大小写翻转，然后返回新的字符串。例如：
```python
x = "I love studying Python"
x.swapcase()
```
#### `upper()`方法
该方法将字符串中所有字母变成大写，然后返回新的字符串。例如：
```python
x = "I love studying Python"
x.upper()
```
#### `lower()`方法
该方法将字符串中所有字母变成小写，然后返回新的字符串。例如：
```python
x = "I love studying Python"
x.lower()
```
+ 根据官方文档的提示，该方法与上方的`casefold()`方法不一样的是该方法只能处理英语

### 字符串的对齐
字符串作为一种文本也应该有对齐这一种说法，在python中提供了4中方法可以实现字符串的左中右对齐。这四种方法均被要求输入`width`参数，该参数用来指定输出字符串的长度，如果参数小于或等于原字符串长度，则输出结果和原字符串无区别，长度和原来的一样没必要对齐了；如果参数大于原字符串，那么会根据提供的方法对字符串进行调整，之后再输出一个新的字符串。另外的一个是`fillchar=''`参数，该参数可以设置剩下的空位用什么字符填充，默认是用空格填充，自己也可以根据需要设置其他的字符。
#### `center(width,fillchar='')`方法
该方法能将字符串居中对齐，然后返回新的字符串。例如：
```python
game = "Genshin impart!Lunarching!"
print(game.center(10)) #width参数小于原字符串，输出与原字符串一样的新字符串
print(game.center(45)) #width参数大于原字符串，居中字符串，两边用空格填充，之后输出新的字符串
print(game.center(45,'!')) #fillchar参数可以设置填充的字符，这里设置的是'!'
```
#### `ljust(width,fillchar='')`方法
该方法能将字符串靠左对齐，然后返回新的字符串。例如：
```python
game = "Genshin impart!Lunarching!"
print(game.ljust(45)) 
```
#### `rjust(width,fillchar='')`方法
该方法能将字符串靠左对齐，然后返回新的字符串。例如：
```python
game = "Genshin impart!Lunarching!"
print(game.rjust(45)) 
```
#### `zfill(width)`方法
该方法先用0填充左侧，然后返回新的字符串。例如：
```python
game = "Genshin impart!Lunarching!"
print(game.ljust(45)) 
```
该方法在处理数据报表的时候比较实用，比如需要统一数值格式。另外该方法也不是一味地在左侧加0，遇到负数的时候会机智处理：
```python
num = "520"
print(num.zfill(6))
num1 = "-520"
print(num1.zfill(6))
```

### 字符串的查找
对于查找字符串，python提供了5个方法可以实现。这5个方法中都有`sub`参数、`start`参数和`end`参数。`sub`参数为子字符串，`start`参数为字符串中起始查找位置，`end`参数为字符串中停止查找的位置。
#### `count(sub[,start[,end]])`方法
该方法用于查找`sub`参数指定的子字符串在字符串中出现的次数。`sub`参数为需要被计数的字符串；`start`为开始计数的位置，依然是用下标索引值表示；`end`为结束计数的位置，依然是用下标索引值表示，**注意这个区间依然是左闭右开**。另外遇到参数说明中有被`[]`的参数指该参数为**可选参数**，就是可要可不要的意思。例如：
```python
x = "一位哔站网友留言说：我用了很久的哔哩哔哩了"
x.count("哔") #整个字符串中出现了几次"哔"
x.count("哔",0,6) #在前6个字符中出现了几次"哔"
x.count("哔",15,22) #在后6个字符中出现了几次"哔"
```
#### `find(sub[,start[,end]])`方法
该方法用于**从左往右**查找`sub`参数指定的子字符串在字符串中第一次出现的下标索引值，如果不存在该字符串则返回`-1`。`sub`参数为需要被查找的字符串；`start`为开始查找的位置，依然是用下标索引值表示；`end`为结束查找的位置，依然是用下标索引值表示，**注意这个区间依然是左闭右开**。
```python
x.find("哔") 
x.find("B")  #不存在"B"这个字符
```
上面的例子中，不存在"B"这个字符，所以程序会返回`-1`这个值。
#### `rfind(sub[,start[,end]])`方法
该方法用于**从右往左**查找`sub`参数指定的子字符串在字符串中第一次出现的下标索引值,如果不存在该字符串则返回`-1`。`sub`参数为需要被查找的字符串；`start`为开始查找的位置，依然是用下标索引值表示；`end`为结束查找的位置，依然是用下标索引值表示，**注意这个区间依然是左闭右开**。
```python
x.rfind("哔")
```
#### `index(sub[,start[,end]])`方法
该方法和`find(sub[,start[,end]])`方法差不多，读取的顺序是一样的，唯一的区别是如果不存在该字符串则会抛出异常。`sub`参数为需要被查找的字符串；`start`为开始查找的位置，依然是用下标索引值表示；`end`为结束查找的位置，依然是用下标索引值表示，**注意这个区间依然是左闭右开**。
```python
x.index("哔")
x.index("B")  #不存在"B"这个字符
```
上面的例子中，不存在"B"这个字符，所以程序会报错，但是如果报错了也不用着急。有的时候我们会故意让程序报错，具体为什么我们之后会了解到，之后也会讲解如何处理异常捕获和处理的这个机制。
#### `rindex(sub[,start[,end]])`方法
该方法和`rindex(sub[,start[,end]])`方法差不多，读取的顺序是一样的，唯一的区别是如果不存在该字符串则会抛出异常。`sub`参数为需要被查找的字符串；`start`为开始查找的位置，依然是用下标索引值表示；`end`为结束查找的位置，依然是用下标索引值表示，**注意这个区间依然是左闭右开**。
```python
x.rindex("哔")
```

### 字符串的替换
在python中，作者提供了三个关于字符串替换的方法。**需要注意的是**字符串是不可变的对象，每一种变换方法之后是根据方法的规则生成的一条新字符串，不是原来的字符串。

#### `expandtabs([tabsize=8])`方法
该方法的作用是使用空格来替换（tab）制表符，同时返回一个新的字符串。例如：
```python
#第一行用的空格缩进，第二行用的tab缩进
code = """
    I love python!
	I love python!"""
new_code = code.expandtabs(4) #这里一个tab对应4个空格，故传入的参数为4
```
+ **【背景】**在平时写代码时，不同的人会用不同的缩进方式，比如直接打四个空格或者是直接用tab制表符，不管用哪一种方法，在一段列表里面不能混合使用tab制表符和空格，否则程序会报错。这种情况一般不用担心，通常情况下，在像`Microsoft visual station code`类似的编辑器中，能够自动将`tab`的输入转换为4个`space`。

#### `replace(old,new,count=-1)`方法
该方法用于将原字符串中指定的内容替换为新的被传入的内容，同时返回新字符串。其中`old`参数为原字符串中需要被替换的子字符串；`new`为要被替换的新字符串；`count`参数为要替换几次，默认为`-1`则是全部替换。例如，将`"今天我想玩原神了，所以——原神！启动！"`中改为"第五人格"：
```python
say = "今天我想玩原神了，所以——原神！启动！"
say.replace("原神","第五人格")
say.replace("原神","第五人格",1) #只替换一次
```

#### `translate(table)`方法
该方法可以将字符串按照传入的`table`参数中的规则替换字符串中的字符，然后输出新的字符串。此时`table`参数需要`str.maketrans(x[,y[,z]])`方法来获取这个表格，该方法中的`x`（第一个）参数是需要被替换的子字符串，`y`（第二个）参数是指替换后的新字符串，`z`（第三个）参数是需要被忽略的字符串。例如：
```python
game = "Genshin impart!Lunarching!"
_ = str.maketrans(abcdefgh,12345678)
game.translate(_)
game.translate(str.maketrans(abcdefgh,12345678))
game.translate(str.maketrans(abcdefgh,12345678,Lunarching))
```

### 字符串的判断
这些方法用于判断传入的字符串在字符串中是否在该方法的位置，是否为大写或小写等等。既然是判断，返回的结果也应该是一个布尔类型的值。
#### `startswith(prefix[,start[,end]])`方法
该方法用于检测传入的子字符串是否位于该字符串的起始位置，该方法也是要区分大小写的。`prefix`参数为需要检查的字符串；`start`为开始检查的位置，依然是用下标索引值表示；`end`为结束检查的位置，依然是用下标索引值表示，**注意这个区间依然是左闭右开**。另外遇到参数说明中有被`[]`的参数指该参数为**可选参数**。例如：
```python
game = "Genshin impart!"
game.startswith("G")
game.startswith("G",1,5)
```
另外该方法支持使用元组传入多个待匹配的字符串用于检查，例如：
```python
dream = "我今天中午想要吃四川火锅"
dream.startswith(("你","我","她","他","它"))
if dream.startswith(("你","我","她","他","它")):
    print("我们今天中午去吃火锅")
```

#### `endswith(prefix[,start[,end]])`方法
该方法用于检测传入的子字符串是否位于该字符串的结束位置，该方法也是要区分大小写的。`prefix`参数为需要检查的字符串；`start`为开始检查的位置，依然是用下标索引值表示；`end`为结束检查的位置，依然是用下标索引值表示，**注意这个区间依然是左闭右开**。例如：
```python
game = "Genshin impart!"
game.startswith("!")
game.startswith("n",1,8)
```
和`startswith(prefix[,start[,end]])`方法一样，该方法也能够使用元组传入多个待匹配的字符串用于检查。

#### `istitle()`方法
该方法用于检测字符串是否是每一个单词开头的字母为大写，其余字母为小写。例如：
```python
words = "I like eating apple"
words.istitle()

words_1 = "Dream Is Possible"
words_1.istitle()
```

#### `isupper()`方法
该方法用于检测字符串是否是每一个字母为大写。例如：
```python
words = "I like eating apple"
words.isupper()

words_1 = "you like eating apple"
words_1.isupper()
words_1.upper.isupper()
```
观察上面的结果`words_1.upper.isupper()`返回值为`True`，**证明了Python执行方法是从左往右的顺序的**。先执行了`upper`方法将所有字母变为大写，然后在执行`isupper`方法进行判断第一个字母是否为大写。

#### `islower()`方法
该方法用于检测字符串是否是每一个字母为小写。和`isupper()`方法的使用方法是完全一样的。

#### `isalpha()`方法
该方法用于判断字符串是不是全部都是字母。例如：
```python
game = "Genshin Impart"
game.isalpha()
game_1 = "GenshinImpart"
game_1.isalpha
```
第一个很显然返回的值是`False`，应为空格也是一个字符，且空格不是字母。

#### `isspace()`方法
该方法用于检测字符串是否是空白字符串。例如：
```python
"       ".isspace
"       \n".isspace
```
观察返回的结果可以知道，tab制表符是空白字符串，空格也是字符串，转义字符`\n`也是空白字符串。所以**空白字符串不指只含有空格的字符串**。

#### `isprintable()`方法
该方法用于检测字符串是否可以被打印。很多人会以为能出现在IDLE中都是能够被打印的，但是转义字符是不能够打印的。例如
```python
"Genshin Impart".isprintable()
"Genshin Impart\n".isprintable() #\n不是一个可打印字符
```

#### `isdecimal()`方法
该方法检测字符串是否为数字，但是当用于该方法的字符串是不需要计算的阿拉伯数字时才会返回`True`。例如：
```python
a = "1234"
b = "2²"
c = "ⅠⅡⅢⅣ"
d = "一二三四"
a.isdecimal()
b.isdecimal()
c.isdecimal()
d.isdecimal()
```
观察结果，只有`a`返回了`True`其他均为`False`。

#### `isdigit()`方法
该方法检测字符串是否为数字，但是当用于该方法的字符串是阿拉伯数字时才会返回`True`。例如：
```python
a = "1234"
b = "2²"
c = "ⅠⅡⅢⅣ"
d = "一二三四"
a.isdigit()
b.isdigit()
c.isdigit()
d.isdigit()
```
观察结果，`a`和`b`返回了`True`其他均为`False`。

#### `isnumeric()`方法
该方法检测字符串是否为数字，只要输入的内容表示数字就会返回`True`。例如：
```python
a = "1234"
b = "2²"
c = "ⅠⅡⅢⅣ"
d = "一二三四"
a.isnumeric()
b.isnumeric()
c.isnumeric()
d.isnumeric()
```
观察结果，全都返回了`True`。

**提示**但不是方法不是接受的尺度越大就越厉害就越要去用它，具体需不需要用这个方法，是要根据程序的需求来判断的。

#### `isalnum()`方法
该方法集成了`isalpha()`，`isdecimal()`，`isdigit()`和`isnumeric()`。当这四个中有一个返回值是`True`，那么该方法的返回值就是`True`

#### `isidentifier()`方法
该方法用于判断这个字符串是否是一个合法的Python标识符。最开始说变量的时候，变量名必须是一个合法的Python标识符。例如：
```python
"Genshin Impart".isidentifiter() #有空格
"Genshin_Impart".isidentifiter() #True
"520www".isidentifiter() #以数字开头
"www520".isidentifiter() #True
```

### 字符串的截取
Python提供了5个方法用于截取字符串。
#### `lstrip(chars="")`方法
该方法用于删去字符串中文字的左侧留白。该方法支持传入参数`chars`表示需要删去的字符，默认为`None`。例如
```python
"        左侧不要留白！".lstrip()
"www.xiaoxincantplaygames.cn".lstrip("wcn.")
```
观察上面的结果，当左侧的字符存在于`chars`传入的字符中，那么就会被删去。

#### `rstrip(chars="")`方法
该方法用于删去字符串中文字的右侧留白。该方法也支持传入参数`chars`表示需要删去的字符，默认为`None`。例如
```python
"右侧不要留白！        ".rstrip()
"www.xiaoxincantplaygames.cn".rstrip("wcn.")
```
观察上面的结果，当右侧的字符存在于`chars`传入的字符中，那么就会被删去。

#### `strip(chars="")`方法
该方法用于删去字符串两端中的所有留白，**不会影响中间的字符**。该方法也同样支持传入参数`chars`表示需要删去的字符，默认为`None`。例如
```python
"         不要留白！        ".strip()
"www.xiaoxincantplaygames.cn".rstrip("wcn.")
```
观察上面的结果，当字符串两端的字符存在于`chars`传入的字符中，那么就会被删去。

#### `removeprefix(prefix)`方法
该方法用于删除字符串中指定的前缀。这个和上面的`lstrip(chars="")`方法的区别是，这个是你指定的是字符串，前面是单个字符，该方法就是你指定什么就删什么，找不到指定的内容就不做任何改变。例如：
```python
"www.xiaoxincantplaygames.cn".removeprefix("www")
"www.xiaoxincantplaygames.cn".removeprefix("www.")
"www.xiaoxincantplaygames.cn".removeprefix("w.")  #前缀没有这个东西
```

#### `removesuffix(suffix)`方法
该方法用于删除字符串中指定的后缀。这个和上面的`rstrip(chars="")`方法的区别是，这个是你指定的是字符串，前面是单个字符，该方法就是你指定什么就删什么，找不到指定的内容就不做任何改变。例如：
```python
"www.xiaoxincantplaygames.cn".removeprefix(".cn")
"www.xiaoxincantplaygames.cn".removeprefix("cn")
"www.xiaoxincantplaygames.cn".removeprefix(".c")  #后缀没有这个东西
```

### 字符串的拆分
Python提供了两个方法可以用于拆分和拼接字符串。
#### `partition(sep)`方法
该方法用于将字符串从左到右寻找第一个出现的`sep`参数进行分割，将分割符前面所有内容作为一个字符串，分割符作为一个字符串，分割符后面所有内容作为一个字符串，传入一个元组，然后返回一个包含三个元素的元组。`sep`参数为需要分割的字符串。例如：
```python
s = "apple,banana,orange"
result = s.partition(',')
```
如果字符串中找不到`sep`传入的参数，那么返回的元组中为该字符串本身，另加两个空元素。例如：
```python
s = "apple"
result = s.partition(',')  #字符串中无','
print(result)  # 输出: ('apple', '', '')
```
具体可以理解为，因为没有`,`这个分隔符，`partition(',')`返回的是：

+ `'apple'`（整个字符串）
+ `''`（没有分隔符）
+ `''`（没有分隔符后的内容）

#### `rpartition(sep)`方法
该方法用于将字符串**从右到左**寻找第一个出现的`sep`参数进行分割，将分割符前面所有内容作为一个字符串，分割符作为一个字符串，分割符后面所有内容作为一个字符串，传入一个元组，然后返回一个包含三个元素的元组。`sep`参数为需要分割的字符串。除了寻找的方向有变化，其他和`partition(sep)`方法一样。

#### `split(sep=None,maxsplit=-1)`方法
该方法将字符串按照传入的参数进行分割，然后将结果传入到一个列表中并返回这个列表。`sep`参数为需要分割的字符串，默认情况下是切割`space`（空格）；`maxsplit`参数是指定要分割的次数，默认情况下为`-1`，指只要遇到分割符就进行分割。例如：
```python
x = "苟日新，日日新，又日新"
x.split()
x.split("，")
x.split("，",1)
```

#### `rsplit(sep=None,maxsplit=-1)`方法
该方法和`split(sep=None,maxsplit=-1)`方法唯一区别就是从右往左切

#### `splitlines(keepends=False)`方法
该方法会将字符串按行进行分割，然后将结果以列表的形式返回。该方法能够识别各种换行符¹，即使是在混用的情况下。`splitlines()`默认是不包含参数的；`keepends`参数表示结果是否保留换行符,默认为`False`不保留换行符，若保留则输出时保留原来的换行符。例如：
+ 在Linux操作系统中，换行符为`\n`；在MacOS中，换行符为`\r`；在Windows操作系统中，换行符为`\r\n`。所以会出现换行符混用的情况
```python
x = "苟日新\n日日新\r又日新"
x.splitlines()
x.splitlines(True)
```

### 字符串的拼接
#### `join(iterable)`方法
该方法用于向字符串中添加字符串，最后合并成为一个字符串并传出新的字符串。`x.join(iterable)`前面的`x`是分割符，用于分开后续加入的对象；`iterable`参数为构成最后的字符串的子字符串，传入的对象应该是可迭代对象（用元组和列表都可以）。例如：
```python
".".join(["www","xiaoxincantplaygames","cn"])
".".join(("www","xiaoxincantplaygames","cn"))
```
当然用加号进行拼接简单的字符串没有任何问题，比如拼接`"Genshin"`和`"Impart"`两个字符串：
```python
x = "Genshin" + "Impart"
y = "".join(["Genshin","Impart"])
```
虽然加号如此简便，小数目的字符串拼接还好，但是如果遇到上万个上百万个字符串进行拼接，加号的效率远不及`join(iterable)`方法。（结果是这样的，大家也可以自己写一个程序试试）

### 格式化字符串
#### 字符串的格式化输出
这个在之前的文章中已经出现过。输出的字符串中涉及到需要替换之前的变量时，会用到格式化输出。格式化输出在字符串中用花括号将需要被变量值替换的字符，然后用格式化字符串将变量值输入进去。语法如下：
```python
#使用语法（仅表示语法结构，代码是不能运行在idle中的）
"吧啦吧啦吧啦 {要被替换的变量名}".format(要被替换的变量名)
print(f"吧啦吧啦吧啦 {要被替换的变量名}") #f-字符串 很多时候用这个，前提是前面对该变量进行了定义
```
在基础语法中，后面的括号（被替换的变量名）本质上是一个元组，所以是可以放多个变量进去，另外前面的字符串中也可以放多个花括号用于替换。由于后面的括号是一个元组，所以每个元素都有一个下标索引值，在前面的字符串的花括号中可以添加下标索引值来表示引用后方括号中的哪一个变量。除此之外，后面的括号也能够添加关键字，只不过相较于其他的方式来说比较麻烦了。上面的几种形式是可以混用的。例如：
```python
"我今天上午先写了{}，然后写了{}，接着写了{}，之后我就吃饭了".format("高等数学","有机化学","C语言") #字符串里面可以有多个{}
"我今天上午先写了{2}，然后写了{0}，接着写了{1}，之后我就吃饭了".format("高等数学","有机化学","C语言") #{}里面可以添加下标索引值
"我今天上午先写了{2}，然后写了{0}，接着写了{2}，之后我就吃饭了".format("高等数学","有机化学","C语言") #同一个元素可以引用多次
"我今天上午先写了{math}，然后写了{chemistry}，接着写了{c}，之后我就吃饭了".format(math="高等数学",chemistry="有机化学",c="C语言") #括号内可以添加关键字（这个是真的麻烦）
"我今天上午先写了{math}，然后写了{1}，接着写了{c}，之后我就吃饭了".format(math="高等数学","有机化学",c="C语言") #可以混用
```
`format()`方法还能支持其他传入的参数。`format()`最终形态应该是如下显示的：
```python
"[[fill]align][sign][#][0][width][grouping_option][.precision][type]".format()
```
其中的意思是
+ `[fill]`：表示填充的字符串
+ `[align]`：表示对齐方式，参数有 |"<"|">"|"="|"^"|
+ `[sign]`：表示正负号，参数有 |"+"|"-"|" "|
+ `[width]`：表示字符串的长度
+ `[grouping_option]`：表示
+ `[.precision]`：表示，参数有digit+
+ `[type]`：表示，参数有digit+

+ 尽请期待

#### f-字符串
字符串前面添加`f`自动填充后面的变量之类的东西，但是更具众多反馈来看是在高版本的Python存在，低版本的Python可能并不具备这一功能。例如：
```python
old = 18
print(f"我今年{old}岁")
```

## 序列
序列可以通过下标索引值来获取每一个元素，且第一个索引值是0；可以通过切片来获取某一个范围的元素；都有很多的运算符。在python中，列表、元组、字符串都统称为序列。根据能否被修改，分为了“可变序列”和“不可变序列”
#### 序列的运算
在四则运算中，只有加号和称号能在序列上。加号表示对序列进行拼接，乘号表示对序列进行重复
+ 敬请期待

## 字典
**在映射关系的数据类型上，字典的效率远高于列表**
+ 敬请期待
